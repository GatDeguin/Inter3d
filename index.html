<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>AR Hands + Cubo 3‑D (v 2.1 — Push con índice)</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
  html,body{margin:0;padding:0;overflow:hidden;width:100%;height:100%;background:#000;}
  video#cam{position:absolute;top:0;left:0;width:100%;height:100%;
            object-fit:cover;transform:scaleX(-1);z-index:0;opacity:1;pointer-events:none;}
  canvas#gl{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;}
  canvas#ol{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2;pointer-events:none;}
  #camSelect{position:absolute;top:8px;right:8px;z-index:3;
             background:#222;color:#fff;font:14px sans-serif;border:none;padding:4px 6px;
             border-radius:4px;opacity:.8;}
</style>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
<select id="camSelect"></select>
<video id="cam" playsinline muted></video>
<canvas id="gl"></canvas>
<canvas id="ol"></canvas>

<script type="module">
/* --- Imports ES --- */
import * as THREE  from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/* --- Bridge globals (MediaPipe) --- */
const Hands=window.Hands, FaceMesh=window.FaceMesh, HAND_CONNECTIONS=window.HAND_CONNECTIONS;

/* --- DOM refs --- */
const video=document.getElementById('cam');
const glC=document.getElementById('gl');
const olC=document.getElementById('ol');
const ctx=olC.getContext('2d',{willReadFrequently:true});
const camSel=document.getElementById('camSelect');

/* --- THREE + CANNON scene --- */
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100);
camera.position.set(0,1.5,3);
const renderer=new THREE.WebGLRenderer({canvas:glC,antialias:true,alpha:true});
renderer.setSize(innerWidth,innerHeight);
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));

const world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
const bounceMat=new CANNON.Material('bounce');
world.defaultContactMaterial.restitution=0.6;

/* Paredes caja 3×3×3 (centro 1.5 m) */
function addWall(size, pos){ const b=new CANNON.Body({mass:0,material:bounceMat});
  b.addShape(new CANNON.Box(size)); b.position.copy(pos); world.addBody(b);}
const t=0.05, box=2;                  // grosor pared, semi‑lado interior 1.5 m
addWall(new CANNON.Vec3(t,box,box), new CANNON.Vec3(-1.5-t,1.5,0));  // izq
addWall(new CANNON.Vec3(t,box,box), new CANNON.Vec3( 1.5+t,1.5,0));  // der
addWall(new CANNON.Vec3(box,t,box), new CANNON.Vec3(0,3+t,0));       // techo
addWall(new CANNON.Vec3(box,t,box), new CANNON.Vec3(0,-t,0));        // suelo
addWall(new CANNON.Vec3(box,box,t), new CANNON.Vec3(0,1.5,-1.5-t));  // frente
addWall(new CANNON.Vec3(box,box,t), new CANNON.Vec3(0,1.5, 1.5+t));  // fondo

/* Cubo físico */
const base=0.3;
const boxBody=new CANNON.Body({
  mass:1, shape:new CANNON.Box(new CANNON.Vec3(base,base,base)), material:bounceMat});
boxBody.position.set(0,1,0); world.addBody(boxBody);
const boxMesh=new THREE.Mesh(
  new THREE.BoxGeometry(base*2,base*2,base*2),
  new THREE.MeshStandardMaterial({color:0x135d8c})); scene.add(boxMesh);

/* ----- NUEVO: cuerpo “dedo” (esfera) ----- */
const fingerRadius=0.05;
const fingerBody=new CANNON.Body({
  type:CANNON.Body.KINEMATIC, mass:0, material:bounceMat});
fingerBody.addShape(new CANNON.Sphere(fingerRadius));
fingerBody.collisionResponse=true;
world.addBody(fingerBody);

/* --- Variables AR / gestos --- */
let handLm=[], faceRes=null;
const colors={thumb:'#F00',index:'#0F0',middle:'#00F',ring:'#FF0',pinky:'#F0F'};
const isPinch=h=>h && Math.hypot(h[4].x-h[8].x,h[4].y-h[8].y,h[4].z-h[8].z)<0.04;
const ray=new THREE.Raycaster();

/* Hand‑proxy para agarre */
let handProxy=null, grabJoint=null, grabbed=false;
let prevPos=new CANNON.Vec3(), lastDt=1/60, scaleInit=null;

/* --- MediaPipe Hands --- */
const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.4,minTrackingConfidence:0.4});
hands.onResults(r=>{handLm=r.multiHandLandmarks||[];});

/* --- MediaPipe FaceMesh --- */
const face=new FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
face.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
face.onResults(r=>{faceRes=r;});

/* ---------- Cámara y selector ---------- */
let stream=null;
async function startStream(deviceId){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  const constraints=deviceId?{video:{deviceId:{exact:deviceId}}}:{video:{facingMode:'user'}};
  stream=await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject=stream; await video.play();

  /* rellena selector */
  const devices=await navigator.mediaDevices.enumerateDevices();
  camSel.innerHTML='';
  devices.filter(d=>d.kind==='videoinput').forEach((d,i)=>{
    const opt=document.createElement('option');
    opt.value=d.deviceId; opt.text=d.label||`Cam ${i+1}`;
    if(d.deviceId===deviceId) opt.selected=true;
    camSel.appendChild(opt);
  });
}
camSel.addEventListener('change',e=>startStream(e.target.value));
startStream(null).catch(e=>alert(e));

/* ---------- Loop 2‑D (landmarks + lógica) ---------- */
async function onFrame(){
  if(video.readyState>=2 && video.videoWidth){
    await hands.send({image:video});
    await face.send({image:video});

    const vw=video.videoWidth,vh=video.videoHeight;
    const cw=olC.width=innerWidth,ch=olC.height=innerHeight;
    const s=Math.min(cw/vw,ch/vh),dw=vw*s,dh=vh*s,dx=(cw-dw)/2,dy=(ch-dh)/2;

    ctx.clearRect(0,0,cw,ch);
    ctx.save(); ctx.translate(cw,0); ctx.scale(-1,1);

    /* ----- draw hands ----- */
    handLm.forEach(lm=>{
      ctx.strokeStyle='#0F0'; ctx.lineWidth=4;
      HAND_CONNECTIONS.forEach(([i,j])=>{
        const p1=lm[i],p2=lm[j];
        ctx.beginPath(); ctx.moveTo(dx+p1.x*dw,dy+p1.y*dh);
        ctx.lineTo(dx+p2.x*dw,dy+p2.y*dh); ctx.stroke();
      });
      lm.forEach((p,i)=>{
        const x=dx+p.x*dw,y=dy+p.y*dh;
        let col='#FFF';
        if(i<=4)col=colors.thumb;else if(i<=8)col=colors.index;
        else if(i<=12)col=colors.middle;else if(i<=16)col=colors.ring;
        else col=colors.pinky;
        ctx.beginPath(); ctx.arc(x,y,8,0,2*Math.PI); ctx.fillStyle=col; ctx.fill();
      });
    });

    /* --- face bbox (igual que antes, omitido por brevedad) --- */
    ctx.restore();

    /* ====== FÍSICA DE GESTOS ====== */
    const [hA,hB]=handLm;

    /* (A) Empujar con índice ------------------------------ */
    if(hA && !grabbed){
      /* uso landmark 8 (índice) */
      const xN=2*hA[8].x-1, yN=-2*hA[8].y+1;
      const planeZ=boxBody.position.z;          // proyectamos al plano Z del cubo
      const dir=new THREE.Vector3(xN,yN,0.5).unproject(camera).sub(camera.position).normalize();
      const t=(planeZ-camera.position.z)/dir.z;
      const worldPos=new THREE.Vector3().copy(camera.position).addScaledVector(dir,t);

      /* actualiza cuerpo kinemático del dedo */
      fingerBody.position.set(worldPos.x,worldPos.y,worldPos.z);

      /* velocidad para colisiones más realistas */
      if(!fingerBody.prev){fingerBody.prev=fingerBody.position.clone();}
      const dv=fingerBody.position.vsub(fingerBody.prev);
      fingerBody.velocity.copy(dv.scale(1/lastDt));
      fingerBody.prev=fingerBody.position.clone();
    }else{
      /* si no hay mano o está agarrando, mueve el dedo fuera de escena */
      fingerBody.position.set(999,999,999);
      fingerBody.velocity.setZero();
      fingerBody.prev=null;
    }

    /* (B) Agarre / mover / soltar ------------------------- */
    if(hA && isPinch(hA) && !grabbed){
      const xN=2*hA[8].x-1, yN=-2*hA[8].y+1;
      ray.setFromCamera({x:xN,y:yN},camera);
      const hit=ray.intersectObject(boxMesh)[0];
      if(hit){
        handProxy=new CANNON.Body({type:CANNON.Body.KINEMATIC, mass:0, material:bounceMat});
        handProxy.position.copy(hit.point);
        world.addBody(handProxy);
        grabJoint=new CANNON.LockConstraint(boxBody,handProxy);
        world.addConstraint(grabJoint);
        prevPos.copy(handProxy.position);
        grabbed=true;
      }
    }
    if(grabbed && handProxy && hA){
      const xN=2*hA[8].x-1,yN=-2*hA[8].y+1;
      const vec=new THREE.Vector3(xN,yN,0.5).unproject(camera);
      const wp=new CANNON.Vec3(vec.x,vec.y,vec.z);
      const delta=wp.vsub(prevPos);
      handProxy.velocity.copy(delta.scale(1/lastDt));
      handProxy.position.copy(wp); prevPos.copy(wp);
      if(!isPinch(hA)){
        boxBody.velocity.copy(handProxy.velocity);
        world.removeConstraint(grabJoint); world.removeBody(handProxy);
        handProxy=grabJoint=null; grabbed=false;
      }
    }

    /* (C) Escala ----------------------------------------- */
    if(hA&&hB){
      const d=Math.hypot(hA[0].x-hB[0].x,hA[0].y-hB[0].y);
      if(isPinch(hA)&&isPinch(hB)){
        if(scaleInit===null) scaleInit=d;
        const f=d/scaleInit;
        boxMesh.scale.setScalar(f);
        const half=base*f;
        boxBody.shapes[0].halfExtents.set(half,half,half);
        boxBody.shapes[0].updateConvexPolyhedronRepresentation();
        boxBody.updateBoundingRadius();
        boxBody.mass=1*Math.pow(f,3); boxBody.updateMassProperties();
      }else scaleInit=null;
    }
  }
  requestAnimationFrame(onFrame);
}
video.addEventListener('playing',onFrame);

/* ---------- Loop 3‑D ---------- */
let last=performance.now();
(function anim(){
  requestAnimationFrame(anim);
  const now=performance.now(),dt=(now-last)/1000; last=now; lastDt=dt;
  world.step(1/60,dt,3);
  boxMesh.position.copy(boxBody.position);
  boxMesh.quaternion.copy(boxBody.quaternion);
  renderer.render(scene,camera);
})();

/* ---------- Responsive ---------- */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
