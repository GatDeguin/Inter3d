<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>AR Hands + Físicas 3‑D (Versión Mejorada)</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
  html,body{margin:0;padding:0;overflow:hidden;width:100%;height:100%;background:#000;}

  /* Cámara en espejo (opacidad 1 para evitar bug WebKit) */
  video#cam{
    position:absolute;top:0;left:0;width:100%;height:100%;
    object-fit:cover;transform:scaleX(-1);z-index:0;opacity:1;pointer-events:none;
  }

  /* Canvas WebGL (cubo) */
  canvas#gl{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;}

  /* Canvas overlay 2‑D (landmarks) */
  canvas#ol{position:absolute;top:0;left:0;width:100%;height:100%;
            z-index:2;pointer-events:none;}
</style>

<!-- MediaPipe (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
<video id="cam" playsinline muted></video>
<canvas id="gl"></canvas>
<canvas id="ol"></canvas>

<script type="module">
/* ------------ Imports ES (Three.js & Cannon‑ES) ------------ */
import * as THREE  from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/* ------------ Bridge globals (MediaPipe) ------------------- */
const Hands            = window.Hands;
const FaceMesh         = window.FaceMesh;
const HAND_CONNECTIONS = window.HAND_CONNECTIONS;

/* ------------ DOM refs ------------------------------------- */
const video  = document.getElementById('cam');
const glC    = document.getElementById('gl');
const olC    = document.getElementById('ol');
const ctx    = olC.getContext('2d',{willReadFrequently:true});

/* ------------ THREE + CANNON set‑up ------------------------ */
const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100);
camera.position.set(0,1.5,3);

const renderer = new THREE.WebGLRenderer({canvas:glC,antialias:true,alpha:true});
renderer.setSize(innerWidth,innerHeight);

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));

const world  = new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
const ground = new CANNON.Body({mass:0,shape:new CANNON.Plane()});
ground.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(ground);

/* Cubo rígido ------------------------------------------------ */
const base   = 0.3;                           // medio‑lado inicial
const boxBody = new CANNON.Body({
  mass:1,
  shape:new CANNON.Box(new CANNON.Vec3(base,base,base))
});
boxBody.position.set(0,1,0);
world.addBody(boxBody);

const boxMesh = new THREE.Mesh(
  new THREE.BoxGeometry(base*2,base*2,base*2),
  new THREE.MeshStandardMaterial({color:0x135d8c})
);
scene.add(boxMesh);

/* ------------ AR / gestos vars ----------------------------- */
let handLm=[], faceRes=null;
const ray     = new THREE.Raycaster();
const colors  = {thumb:'#F00',index:'#0F0',middle:'#00F',ring:'#FF0',pinky:'#F0F'};
const isPinch = h=>h && Math.hypot(h[4].x-h[8].x,h[4].y-h[8].y,h[4].z-h[8].z) < 0.04;

/* proxy kinemático de la mano */
let handProxy=null, grabJoint=null, grabbed=false;
let prevPos = new CANNON.Vec3();              // para velocidad
let lastDt  = 1/60;                           // dt último step física
let scaleInit=null;

/* ------------ MediaPipe Hands ------------------------------ */
const hands = new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.4,minTrackingConfidence:0.4});
hands.onResults(r=>{handLm=r.multiHandLandmarks||[];});

/* ------------ MediaPipe FaceMesh --------------------------- */
const face = new FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
face.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
face.onResults(r=>{faceRes=r;});

/* ------------ Cámara --------------------------------------- */
navigator.mediaDevices.getUserMedia({
  video:{facingMode:'user',width:{ideal:1280},height:{ideal:720},frameRate:{ideal:30}}
}).then(s=>{
  video.srcObject=s;
  video.addEventListener('canplay',()=>{video.play(); onFrame();});
}).catch(e=>alert('Permiso de cámara denegado:\n'+e));

/* ------------ Loop 2‑D (landmarks + gestos) ---------------- */
async function onFrame(){
  if(video.readyState>=2 && video.videoWidth){
    await hands.send({image:video});
    await face.send({image:video});

    const vw=video.videoWidth, vh=video.videoHeight;
    const cw=olC.width=innerWidth, ch=olC.height=innerHeight;
    const s=Math.min(cw/vw,ch/vh), dw=vw*s, dh=vh*s, dx=(cw-dw)/2, dy=(ch-dh)/2;

    ctx.clearRect(0,0,cw,ch);

    /* ----- dibujar manos ----- */
    ctx.save(); ctx.translate(cw,0); ctx.scale(-1,1);
    handLm.forEach(lm=>{
      ctx.strokeStyle='#0F0'; ctx.lineWidth=4;
      HAND_CONNECTIONS.forEach(([i,j])=>{
        const p1=lm[i], p2=lm[j];
        ctx.beginPath();
        ctx.moveTo(dx+p1.x*dw,dy+p1.y*dh);
        ctx.lineTo(dx+p2.x*dw,dy+p2.y*dh);
        ctx.stroke();
      });
      lm.forEach((p,i)=>{
        const x=dx+p.x*dw, y=dy+p.y*dh;
        let col='#FFF';
        if(i<=4)col=colors.thumb; else if(i<=8)col=colors.index;
        else if(i<=12)col=colors.middle; else if(i<=16)col=colors.ring;
        else col=colors.pinky;
        ctx.beginPath(); ctx.arc(x,y,8,0,2*Math.PI); ctx.fillStyle=col; ctx.fill();
      });
    });

    /* ----- dibujar cara ----- */
    if(faceRes?.multiFaceLandmarks?.length){
      const lm=faceRes.multiFaceLandmarks[0];
      let minX=1,minY=1,maxX=0,maxY=0;
      lm.forEach(p=>{minX=Math.min(minX,p.x);minY=Math.min(minY,p.y);
                     maxX=Math.max(maxX,p.x);maxY=Math.max(maxY,p.y);});
      ctx.strokeStyle='#0F0'; ctx.lineWidth=3;
      ctx.strokeRect(dx+minX*dw,dy+minY*dh,(maxX-minX)*dw,(maxY-minY)*dh);
    }
    ctx.restore();

    /* ----- gestos / física ----- */
    const [hA,hB]=handLm;

    /* 1) Agarre -------------------------------------------------- */
    if(hA && isPinch(hA) && !grabbed){
      const xN=2*hA[8].x-1, yN=-2*hA[8].y+1;
      ray.setFromCamera({x:xN,y:yN},camera);
      const hit=ray.intersectObject(boxMesh)[0];
      if(hit){
        handProxy=new CANNON.Body({type:CANNON.Body.KINEMATIC, mass:0});
        handProxy.position.copy(hit.point);
        world.addBody(handProxy);
        grabJoint=new CANNON.LockConstraint(boxBody,handProxy);
        world.addConstraint(grabJoint);
        prevPos.copy(handProxy.position);
        grabbed=true;
      }
    }

    /* 2) Mover mientras agarrado -------------------------------- */
    if(grabbed && handProxy && hA){
      const xN=2*hA[8].x-1, yN=-2*hA[8].y+1;
      const vec=new THREE.Vector3(xN,yN,0.5).unproject(camera);
      const worldPos=new CANNON.Vec3(vec.x,vec.y,vec.z);

      /* velocidad = Δpos / dt */
      const delta=worldPos.vsub(prevPos);
      handProxy.velocity.copy(delta.scale(1/lastDt));
      handProxy.position.copy(worldPos);
      prevPos.copy(worldPos);

      /* Soltar */
      if(!isPinch(hA)){
        boxBody.velocity.copy(handProxy.velocity);
        boxBody.angularVelocity.copy(handProxy.angularVelocity);
        world.removeConstraint(grabJoint); world.removeBody(handProxy);
        handProxy=grabJoint=null; grabbed=false;
      }
    }

    /* 3) Escala con dos manos ----------------------------------- */
    if(hA&&hB){
      const d=Math.hypot(hA[0].x-hB[0].x,hA[0].y-hB[0].y);
      if(isPinch(hA)&&isPinch(hB)){
        if(scaleInit===null) scaleInit=d;
        const f=d/scaleInit;
        boxMesh.scale.setScalar(f);
        const half=base*f;
        boxBody.shapes[0].halfExtents.set(half,half,half);
        boxBody.shapes[0].updateConvexPolyhedronRepresentation();
        boxBody.updateBoundingRadius();
        boxBody.mass = 1 * Math.pow(f,3);     // masa ∝ volumen
        boxBody.updateMassProperties();
      }else scaleInit=null;
    }
  }
  requestAnimationFrame(onFrame);
}

/* ------------ Loop 3‑D (física + render) ------------------- */
let lastT=performance.now();
(function anim(){
  requestAnimationFrame(anim);
  const now=performance.now(); const dt=(now-lastT)/1000; lastT=now;
  lastDt=dt;
  world.step(1/60,dt,3);                 // sub‑stepping 3
  boxMesh.position.copy(boxBody.position);
  boxMesh.quaternion.copy(boxBody.quaternion);
  renderer.render(scene,camera);
})();

/* ------------ Responsive ----------------------------------- */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
