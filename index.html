<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>AR Hands + Cubo 3‑D — Debug</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
html,body{margin:0;padding:0;overflow:hidden;width:100%;height:100%;background:#000;}
video#cam{
  position:absolute;top:0;left:0;width:100%;height:100%;
  object-fit:cover;transform:scaleX(-1);          /* espejo */
  z-index:0;opacity:1;pointer-events:none;
}
canvas#gl {position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;}
canvas#ol {position:absolute;top:0;left:0;width:100%;height:100%;z-index:2;pointer-events:none;}
#hud{
  position:absolute;top:8px;left:8px;z-index:3;
  background:rgba(0,0,0,.5);color:#0f0;font:12px monospace;
  padding:4px 6px;border-radius:4px;min-width:120px;
}
</style>

<!-- MediaPipe (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
<div id="hud">⏳ init…</div>
<video id="cam" playsinline muted></video>
<canvas id="gl"></canvas>
<canvas id="ol"></canvas>

<script type="module">
/* ---------- Imports ES (Three + Cannon) ---------- */
import * as THREE  from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/* ---------- Bridge globals -> módulo ---------- */
const Hands=window.Hands, FaceMesh=window.FaceMesh, HAND_CONNECTIONS=window.HAND_CONNECTIONS;

/* ---------- DOM refs ---------- */
const vid=document.getElementById('cam');
const glC=document.getElementById('gl');
const olC=document.getElementById('ol');
const ctx=olC.getContext('2d',{willReadFrequently:true});
const hud=document.getElementById('hud');

/* ---------- Three + Cannon ---------- */
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100);
camera.position.set(0,1.5,3);

const renderer=new THREE.WebGLRenderer({canvas:glC,antialias:true,alpha:true});
renderer.setSize(innerWidth,innerHeight);

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));

const world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
const ground=new CANNON.Body({mass:0,shape:new CANNON.Plane()});
ground.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(ground);

const base=0.3;
const boxBody=new CANNON.Body({mass:1,shape:new CANNON.Box(new CANNON.Vec3(base,base,base))});
boxBody.position.set(0,1,0); world.addBody(boxBody);
const boxMesh=new THREE.Mesh(new THREE.BoxGeometry(base*2,base*2,base*2),
                             new THREE.MeshStandardMaterial({color:0x135d8c}));
scene.add(boxMesh);

/* ---------- Variables de AR ---------- */
let handLm=[], faceRes=null;
let grabbed=false, handProxy=null, grabJoint=null, scaleInit=null;
const ray=new THREE.Raycaster();
const fingerCol={thumb:'#F00',index:'#0F0',middle:'#00F',ring:'#FF0',pinky:'#F0F'};
const isPinch=h=>h && Math.hypot(h[4].x-h[8].x,h[4].y-h[8].y,h[4].z-h[8].z)<0.04;

/* ---------- MediaPipe Hands ---------- */
const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.3,minTrackingConfidence:0.3});
hands.onResults(r=>{handLm=r.multiHandLandmarks||[]; console.log('🖐️',handLm.length);});

/* ---------- FaceMesh ---------- */
const face=new FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
face.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
face.onResults(r=>{faceRes=r;});

/* ---------- Cámara ---------- */
navigator.mediaDevices.getUserMedia({
  video:{facingMode:'user',width:{ideal:1280},height:{ideal:720},frameRate:{ideal:30}}
})
.then(s=>{
  vid.srcObject=s;
  vid.addEventListener('canplay',()=>{vid.play(); onFrame();});
})
.catch(e=>{hud.textContent='❌ cam: '+e; console.error(e);});

/* ---------- Loop 2‑D ---------- */
let frames=0, lastT=performance.now();
async function onFrame(){
  try{
    if(vid.readyState>=2 && vid.videoWidth){
      await hands.send({image:vid});
      await face.send({image:vid});

      /* FPS */
      frames++; const now=performance.now();
      if(now-lastT>1000){
        hud.textContent=`fps ${frames} | manos ${handLm.length} | caras ${faceRes?.multiFaceLandmarks?.length||0}`;
        frames=0; lastT=now;
      }

      /* Canvas prep */
      const vw=vid.videoWidth,vh=vid.videoHeight;
      const cw=olC.width=innerWidth, ch=olC.height=innerHeight;
      const s=Math.min(cw/vw,ch/vh),dw=vw*s,dh=vh*s,dx=(cw-dw)/2,dy=(ch-dh)/2;
      ctx.clearRect(0,0,cw,ch);

      /* ----- draw hands ----- */
      ctx.save(); ctx.translate(cw,0); ctx.scale(-1,1);
      handLm.forEach(lm=>{
        ctx.strokeStyle='#0F0'; ctx.lineWidth=6;
        HAND_CONNECTIONS.forEach(([i,j])=>{
          const p1=lm[i],p2=lm[j];
          ctx.beginPath();
          ctx.moveTo(dx+p1.x*dw,dy+p1.y*dh);
          ctx.lineTo(dx+p2.x*dw,dy+p2.y*dh);
          ctx.stroke();
        });
        lm.forEach((p,i)=>{
          const x=dx+p.x*dw,y=dy+p.y*dh;
          let col='#FFF';
          if(i<=4)col=fingerCol.thumb;else if(i<=8)col=fingerCol.index;
          else if(i<=12)col=fingerCol.middle;else if(i<=16)col=fingerCol.ring;
          else col=fingerCol.pinky;
          ctx.beginPath(); ctx.arc(x,y,14,0,2*Math.PI);
          ctx.fillStyle=col; ctx.fill();
        });
      });

      /* ----- draw face bbox ----- */
      if(faceRes?.multiFaceLandmarks?.length){
        const lm=faceRes.multiFaceLandmarks[0];
        let minX=1,minY=1,maxX=0,maxY=0;
        lm.forEach(p=>{minX=Math.min(minX,p.x);minY=Math.min(minY,p.y);
                       maxX=Math.max(maxX,p.x);maxY=Math.max(maxY,p.y);});
        ctx.strokeStyle='#0F0'; ctx.lineWidth=4;
        ctx.strokeRect(dx+minX*dw,dy+minY*dh,(maxX-minX)*dw,(maxY-minY)*dh);
      }
      ctx.restore();

      /* ----- gestos sobre cubo ----- */
      const [hA,hB]=handLm;
      if(hA && isPinch(hA) && !grabbed){
        const xN=2*hA[8].x-1, yN=-2*hA[8].y+1;
        ray.setFromCamera({x:xN,y:yN},camera);
        if(ray.intersectObject(boxMesh)[0]){
          handProxy=new CANNON.Body({mass:0});
          handProxy.position.copy(boxBody.position); world.addBody(handProxy);
          grabJoint=new CANNON.LockConstraint(boxBody,handProxy); world.addConstraint(grabJoint);
          grabbed=true;
        }
      }
      if(grabbed && handProxy && hA){
        const xN=2*hA[8].x-1, yN=-2*hA[8].y+1;
        handProxy.position.copy(new THREE.Vector3(xN,yN,0.5).unproject(camera));
        if(!isPinch(hA)){world.removeConstraint(grabJoint); world.removeBody(handProxy);
                         grabJoint=handProxy=null; grabbed=false;}
      }
      if(hA&&hB){
        const d=Math.hypot(hA[0].x-hB[0].x,hA[0].y-hB[0].y);
        if(isPinch(hA)&&isPinch(hB)){
          if(scaleInit===null) scaleInit=d;
          const f=d/scaleInit; boxMesh.scale.setScalar(f);
          const half=base*f;
          boxBody.shapes[0].halfExtents.set(half,half,half);
          boxBody.shapes[0].updateConvexPolyhedronRepresentation();
          boxBody.updateBoundingRadius();
        }else scaleInit=null;
      }
    }
  }catch(err){
    hud.textContent='⚠️ ERROR';
    console.error(err);
  }
  requestAnimationFrame(onFrame);
}

/* ---------- Loop 3‑D ---------- */
let pt=performance.now();
(function anim(){
  requestAnimationFrame(anim);
  const n=performance.now(),dt=(n-pt)/1000; pt=n;
  world.step(1/60,dt,3);
  boxMesh.position.copy(boxBody.position);
  boxMesh.quaternion.copy(boxBody.quaternion);
  renderer.render(scene,camera);
})();

/* ---------- Responsive ---------- */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
